/*
notes to self:
-sätt solution som en global variabel istället?
-i funktionen get_area: kanske representera områden som sammanslagning av noder?
antag att vi har fyra områden i en yta och två rand områden till ytan. skapa en struct "yta" som innehåller antal ränder, lista med pekare på structen rand. structen rand i sin tur innehåller en lista med pekare på rand-områden samt en parameter som visar randens karaktär.

*/
//  function call-order:


//---------------variabel definitions---------------------------  
#define TRUE 1;
#define FALSE 0;

struct greedy{
  int tile_distance[]; //tabell med avståndet mellan alla nod-par
  int total_area[];  //total_area={totalt antal områden,r1,k1, r2,k2,...}, område1=(r1,k1)
  struct Node node_matrix; //B[][]
  int Break[]; //brytvillkor för algoritm{nuvarande värde, givet brytvillkor}
  int solution[]; //solution= {antal jagare,antal steg, sj1r1,sj1k1,..., sj1r2,sj1k2,...}
}


//-------------------end variabel definitions----------------------








//===========********======PREGREEDY========**********=============
struct greedy preGreedy(struct Node *NodeMat, int *Hunters, int BREAK);{
  int tile_distance[];
  int total_area[];
  alloc_Matrix_enviroment();
  createTables(int *tile_distance, int *total_area);
  struct greedy start;
  start.tile_distance=tile_distance[];
  start.total_area=total_area[];
  start.node_matrix=NodeMatrix[][];
  start.solution=Hunters[];
  start.Break=BREAK;
  return start;
}


void alloc_Matrix_enviroment(){
  //allokera minne för nodmatris
}
void createTables(int *tile_distance, int *total_area){
  get_node_distance(int tile_distance);
  get_total_area(int total_area);
}

void get_node_distance(int tile_distance){

}

void get_total_area(int total_area){

}

//*************************END PREGREEDY*******************************







//%%%%%%%%%%%%%%%%%%%%%------GREEDY------&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

void greedyAlg(struct greedy *input){
  int i=0;
  while (run(int input.solution[],int input.Break)==TRUE){
    one_iteration(struct greedy *input);
}
  release_alloc_Matrix_enviroment();
  return//output är samma som input, men vi har trixat med structen.
}

int run(struct greedy *input){
  if (enviroment_cleared()==TRUE){
    return FALSE;
  }else if(test_break(input)==TRUE){
    return FALSE;
  }else{
    return TRUE;}
 }
int enviroment_cleared(){
  /*
kolla om området är säkrat i nuläget
   */
  if(){
    //område säkrat
    return FALSE
}

  return TRUE;
}
int test_break(struct greedy *input){
  if (input.Break[0]==input.Break[1]){
    return FALSE;
  }
  return TRUE;
}

void release_alloc_Matrix_enviroment(){
  // släpp allokerat minne för matrisen NodeMatrix
}

void one_iteration(struct greedy *input, int *move_strat){
  
  preparations(); //tar fram nödvändig data för en iteration
  evaluation(*move_strat); //beräknar kostnader
  move(struct greedy *input); // flyttar till bästa kostnad
  return;
}

/*===================one_iteration(): Phase one, Preparations================================*/
preparation(){ //tar fram alla startdata för en iteration
 struct Area{
    int area_type;
    struct Node area_adress; //pekar på en nod inom ett ickesett område.
    struct Node boundry; //pekar på rand-noderna till ett ickesett område.
}
 int team_vision[];
 get_conditions(int team_vision); 
 get_hunter_equiv();

 return ??;
}

get_conditions(int *team_vision, struct greedy *input){ //fastställ vilka områden som finns utanför synfält, namnge och definiera ränder
  get_vision(*input); //skriv in gruppens sikt som states i NodeMatrix
  get_areas(*input);
  return;
}

void get_vision(struct greedy *input){
  //find the total sight of the team, function partly solved in greedy.c ??
/*
förslag:
loop
-ta position från en jagare
-ändra state i aktuell nod
-hämta vision för aktuell nod
-ändra states till synlig i de rutor som finns i vision.
loop end
*/
  return;
}

get_areas(struct greedy *input){
  struct Node areaindex[];
  struct Node *p1;
  *p1=areaindex[0];
  subtract_vision(p1, *team_vision); //compare areas in sight of team with total amount of tiles.
  int i=0;
  while(i<areaindex){
    identify_boundry(areaindex[i]);
    i++;
  }
}

subtract_vision(struct Node area, int *team_vision){
  /*

ta fram index på de områden som inte ligger inom synfältet.
 
förslag:
-ta in global tabel med alla områden
-ta in array med team_vision
-ta fram punkt (i,j) ur tabell med alla områden
-kolla om samma punkt finns i team_vision
-om inte: 

   */
}

identify_boundry(int areaindex){
  find_boundry(areaindex);
  classify_boundry(area, boundry);
}

find_boundry(int areaindex){
  //find the boundrys to the given area
  return boundry, number of boundrys;
}

classify_boundry(area, boundry){
  int prio=check_boundry_priority(area,boundry);
  set_boundry(boundry, prio);
  return;
}

check_boundry_priority(area, boundry){
  /*givet en yta och tillhörande ränder:
-är ytan är säkrad -> prio=5
-kan man se hela ytan från alla områden på randen?
         -ja: är antalet områden i randen mer än ett?
	           -ja: prio ->3
		   -nej:prio ->1
         -nej: är antalet områden i randen mer än ett?
                   -ja: prio->4
		   -nej: prio->2
  */
}

set_boundry(boundry, prio){
  //tillskriv randen den medskickade prioriteten.

}


get_hunter_equiv(){
  /*
-ta aktuell nod.
-undersök om flyttbara noders synfält redan finns med inom aktuellt synfält från gruppen
-om det finns någon ekvivalent position: skapa en fiktiv jagare
   */
  return;
}

/*====================one_iteration():Phase two, Evaluation=======================================*/
evaluation(int *next_move){ //använder data från preparation och designerar värden till noder som går at flytta till
  /*
vill veta från preparation:
-antal områden
-fullständig rand till varje område
-karaktär på rand a,b,c,d,e
-jagarpositioner
*/

  if (antal_jagare<=antal_områden){
    designate_boundry(antal_jagare);
  }else {
    designate_boundry(antal_områden);
}
  int i=0;
  while(i<antal_jagare){
    add_geometric_value();
    *next_move=find_best_cost();
  }
  return;
}
  /*handskriven pseudo:
-räkna ut avstånd för alla jagare till rand för varje område
-om antal jagare <=antal områden:
        -välj ett område till varje jagare, så att summan av avstånden blir kortast möjliga
	-områden av sorten a,c måste väljas i första hand
-om antal jagare >antal områden:
        -addera värde i de riktningar som är närmast någon rand
	-addera värde i de riktningar som man ser mest
	-addera värde i de riktningar där jagaren fortfarande håller uppsikt över unika ränder

för alla jagare:
        -addera värde i de riktningar som är närmast någon rand
	-addera värde i de riktningar som man ser mest
	-addera värde i de riktningar där jagaren fortfarande håller uppsikt över unika ränder
	-addera värde i de riktningar där jagaren ser ränder av typen a,c,e
	-kolla vilken nod som ger bäst kostnad
	-spara den noden som planerad att gå till

return lista med planerad flyttstrategi.
	           
*/

}

/*====================one_iteration(): Phase three, Movement======================================*/

move(struct greedy *input){ //använder data från evaluation, flyttar till de noder med bäst kostnad, updaterar states, skickar resultat av en iteration.
  int i=1;//index för jagarnummer.
  struct Node *from;
  struct Node *to;
  int index;
  while (i<=input.solution[0]){ //input.solution[0]= antal jagare
    from =&get_hunter(input, i,r,k); //get current hunter position
    to=get_bestmove(from); //find the moveable tile to move
    put_movestrat(index, from, to); // move and update the number of moves made
} 
  update_states(); //jämför tillstånd för förflyttning med efter, uppdaterar tillståndsändringar
  return;
}

void get_hunter(struct greedy *input,int i){
  int antaljagare= input.solution[0];
  int antalsteg= input.solution[1];
  int rindex=(2*antaljagare*antalsteg+1)+i;
  int kindex=(2*antaljagare*antalsteg+1)+2i;
  int r=input.solution[rindex];
  int k=input.solution[kindex];
  return input.NodeMatrix.[r][k];
}

struct Node get_bestmove(from){ 
 /*
-hämta nod (r,k) ur NodeMatrix
-hämta vilken nod som har bäst värde enligt utdata från evaluation()
- sätt to=nod som ska flyttas till
   */
 return to
}

void put_movestrat(int startindex,struct Node *from, struct Node *to){
  /*
-hämta nya positioner genom to.name[]
-beräkna rätt index att placera de nya positionerna på i solution[]
-lägg in jagarnas nya positionerpositioner i slutet på solution[]
-addera ett till solution [1] (antal steg gjorda)
  */
  return;
}

void update_states(){
  /*
-läs av nuvarande states i NodeMatrix
-jämför förhållande före och efter förflyttning
-updatera de states som har förändrats.
   */
  return;
}


//XXXXXXXXXXXXXXXXXXX---------END GREEDY---------XXXXXXXXXXXXXXXXXXXXXXXX

/*

       one iteration:
-----------------Phase One, Preparations-----------------------------
       hunterVision() - evaluates starting conditions 
       nameCont() - name all contamined areas
       identifyBoundry() - indentify boundry category a,b,c,d,e
       extendBoundry() - extend boundrys of category a,c
       findEquiv() - find possible equivalent hunter positions
---------------------------------------------------------------------
*********************************************************************
-----------------Phase Two, Cost Evaluatuion-------------------------	   
       evalCost() - purpose: run costfunctions and designate values for each direction
         evalDist() - evaluate distance for each hunter to each boundry
           if (number of hunters)>= (number of areas){
	       designateArea(HigH) - designate one area to each hunter, category a,c must be chosen.
	       addDirection() - add value to the directions that doesn't increase the distance to designated boundry
           }
	   else {
	       designateArea(Low) - designate one hunter to each area, category
	       addDirection() - add values to the directions that dosen't increase the distance to designated boundry
	   }
	 
         addGuardUniqueBound() - add value to directions closest to boundry
         addCatAC() - add value to directions where boundrys of category A and C are guarded uniquely
	 addGuardVision() - add value to directions with maximum vision
	 addOddness() - add a small value to a direction, to disable problems with extreme symmetry
	 
---------------------------------------------------------------------
*********************************************************************
-----------------Phase three, move ----------------------------------
         moveHunter() - moves hunters to maximum gain positions according to evalCost()
	 uppdateEnv() - uppdate states and enviroment
---------------------------------------------------------------------
return: array with move strategy. 
