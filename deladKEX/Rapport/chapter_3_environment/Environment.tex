\chapter{Simulation Environment}
%The chapter gives a description of the simulation environment we have created. Presenting how we created it, why we needed to create it and motivation of the choices made. First we give an short overview of the parts that are in the enviroment, and a definition of in/out data. Motivating all our choices made concerning limitations in the enviroment, and also describing positive features of our enviroment.\\
In order to attain the data needed for a comparison of our different algorithms it was nessecary to construct a good testing enviroment. We decided to create this enviroment by the use of two separate parts. One part is called the "Map generator". This part creates a map of the enviroment, tests the feasibility and prints feasible enviroments into an output file. The other part is called the "Network generator". This part reads in an enviroment from a file, creates a graph network to the corresponding map and gives each node in the network its relevant information.\\

\section{Map generator}
The Map Generator (MG) creates random feasible enviroments. A feasible enviroment is described more in detail in section 2, but in short one could say that an enviroment is feasible if it is simply connected and can be divided into a finite set of convex regions. Given the desired size and the density (percentage of obstacles per total area) as inputs, MG creates square shaped feasible enviroment with randomly placed obstacles and saves the map in an external file. For simplicity we have chosen to construct enviroments consisting only of square regions. We suggest that this does not result in a loss of generality since any feasible enviroment can be approximated arbitrarily good by a sufficiently fine meshing of squares. \\
We will now show in a more detailed maner how the MG works. First we present some pseudo code describing the algorithm and then some in depth comments to the code.\\
pseudo-code, Map Generator:
\begin{verbatim}
1  input variables:
2  int Size;  // Specifies the width and height of the square matrix  A.
3  int NumberOfEnv; // Specifies how many feasible enviroments to create.
4  int Obstacle; //  Specifies the number of obstacles in percents, e.g. number of obstacles per total area of A.
5  
6  while ( int i < NumberOfEnv ){
7  	int A = CreateMatrix(int Size); 
8  	PlaceObstacle(int A, int Obstacle);
9  	if (Test(int A)=TRUE){ 
10 		fprintf( fileOK, "\n \n");
11 		i++;
12 	}else{
13 		fprintf{file NotOk, "Does not work: \n");
14 	}
15 }
\end{verbatim}

\begin{itemize}
\item So, first we introduce the needed variables to define how many and what kind of enviroments to create. 
\item The algorithm starts off by entering a while loop running until the loops content has created the desired amount of feasible enviroments. 
\item The function CreateMatrix(int arg) creates an matrix of dimensions $(arg \times arg)$ with every element equal to one. In our map a one corresponds to a feasible square region for the pursuer or evader to thread. 
\item Next we call the function PlaceObstacle(int A, int Obstacle). This function takes the input matrix A and using a randomizing function rand() places zeros in the matrix. The zeros corresponds to obstacles, e.g. squares that can't be seen through and can't med treaded.
\item The function Test (int A) tests if the ones in the given matrix A are connected. If A is connected the enviroment is feasible and the function returns TRUE, if not it returns FALSE. First Test() finds the first element equal to one, starting from the upper left corner going to the right. When such element has been found its index is pushed on a stack. Next we enter a loop that runs for as long as the stack is not empty. First it pops an index from the stack and checks if this index has been accounted for (e.g. if it lies within a vector C). If not accounted for, all the neighbor elements that are equal to one has their index pushed on the stack. Lastly the poped index is put into C, since it has been accounted for. The algorithm starts over by poping a new index and rerunning the loop. 
\end{itemize}

\section{Network Generator}
The Network Generator (NG) generates a node network from an environment matrix. Each node contains data of its adjacent nodes, all the nodes visible from it and its current state. For input the NG uses an environment matrix that is either created by the MG or by hand.\\
\\
\noindent Pseudo-code, Node Network Generator:\\
\indent Read environment matrix A\\
\indent Represent each element in A with a node in a matrix B\\
\indent For each node in B:\\
\indent \indent Set name to its position in the matrix\\
\indent \indent Find and store all nodes that is adjacent to the current node\\
\indent \indent Find and store all visible nodes
%%To find the visible nodes we start in the node that we wish to calculate visible nodes for. From there we step through each allowed node to the left, adding every node upwards that is %%allowed and at most the same number of moves upwards that the previous step allowed. By then repeating this for every node downwards, and finally repeating everything for every %%allowed node to the right, each node that the starting node can see is discovered. Due to the choice of using square regions, limiting the number of allowed steps upwards and %%downwards for each step to the left and right guarantees that the set of visible nodes will be correct.