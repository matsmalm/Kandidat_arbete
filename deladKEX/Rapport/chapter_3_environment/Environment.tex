\chapter{Simulation Environment}
%The chapter gives a description of the simulation environment we have created. Presenting how we created it, why we needed to create it and motivation of the choices made. First we give an short overview of the parts that are in the enviroment, and a definition of in/out data. Motivating all our choices made concerning limitations in the enviroment, and also describing positive features of our enviroment.\\
In order to attain the data needed for a comparison of our different algorithms it was nessecary to construct a good testing enviroment. We decided to create this enviroment by the use of two separate parts. One part is called the "Map generator". This part creates a map of the enviroment, tests the feasibility and prints feasible enviroments into an output file. The other part is called the "Network generator". This part reads in an enviroment from a file, creates a graph network to the corresponding map and gives each node in the network its relevant information.\\

\section{Map generator}
The Map Generator (MG) creates random feasible enviroments. A feasible enviroment is described more in detail in section 2, but in short one could say that an enviroment is feasible if it is simply connected and can be divided into a finite set of convex regions. Given the desired size and the density (percentage of obstacles per total area) as inputs, MG creates square shaped feasible enviroment with randomly placed obstacles and saves the map in an external file. For simplicity we have chosen to construct enviroments consisting only of square regions. We suggest that this does not result in a loss of generality since any feasible enviroment can be approximated arbitrarily good by a sufficiently fine meshing of squares. \\


pseudo-code, Map Generator:\\
\begin{verbatim}
input variables:\\
int size; //Specifies the width and height of the square matrix  A.\\
int NumberOfEnv; // Specifies how many feasible enviroments to create.\\
int Obstacle; //  Specifies the number of obstacles in percents, e.g. number of obstacles per total area of A.\\
\\
while (created feasible enviroments is less than the variable NumberOfEnv )\\
	Create a matrix A with all elements set to one; \\
	in a random maner, turn elements in A to zero (corresponding to obstacles) until the desired amount of obstacles have been placed.\\
	Test if A is connected\\
	if A is connected write the matrix A to the file OK.out\\
	if A is not connected write the matrix to a file NotOK.out\\
\end{verbatim}

\section{Network Generator}
The Network Generator (NG) generates a node network from an environment matrix. Each node contains data of its adjacent nodes, all the nodes visible from it and its current state. For input the NG uses an environment matrix that is either created by the MG or by hand.\\
\\
\noindent Pseudo-code, Node Network Generator:\\
\begin{verbatim}
1. int A = environmentFromFile();\\
2. Node B = createNodeMatrix();\\
3. for(Node N in B):\\
\indent 3.1. setName(); // Set name to the row and column for N in B.\\
\indent 3.2. setMove();\\
\indent 3.3. setVision();\\
\end{verbatim}
\begin{itemize}
\item environmentFromFile() sets A to an environment matrix, consisting of zeros and ones, which is read from an input file. The file can be generated by the MG or constructed by hand.\\
\item A Node is a datastructure that contains a name, pointers to all adjacent Nodes and pointers to all Nodes that can be seen by the actual Node.\\
\item createNodeMatrix() sets B to a matrix of the same dimensions as A, where each element is of the datatype Node.\\
\item setMove() creates pointers from N to all feasible vertically and horizontally adjacent nodes.
\item setVision() creates a list of pointers to all visible Nodes in B from the Node N. Visible Nodes is each Node that can be connected to N by a straight line without passing through a non-feasible Node. The visible nodes are decided by first calculating U_max and D_max which is the number of columns between N and the first non-feasible Node upwards and downwards in the same row, and L_max and R_max which is the number of rows between N and the first non-feasible Node in the same column as N. Each Node up to L_max columns to the left of N and R_max columns to the right of N is visible. For each of these Nodes every Node that is feasible and in the same column, at most U_max rows above or the first non-feasible Node, whichever comes first, and at most D_max rows below or the first non-feasible Node, is visible. U_max and D_max is re-calculated for every column to the left and to the right of N, and is the minimum of the number of the current Nodes U_max and U_max for the previous Node in the same row, with the same applying for D_max.
\end{itemize}